##### load packages -----
library(dplyr)
library(brms)
library(rstan)
library(ggplot2)
library(bayestestR)

##### load data as CSV files -----
updated_comb <- read.csv("G:/.shortcut-targets-by-id/15aIOTzK-SdA0QZzPxWaQk_8cNO0OoEUl/Rebekah thesis/SUPPLEMENTATION PAPER/Data sheets/updated_comb.csv")
updated_weight <- read.csv("G:/.shortcut-targets-by-id/15aIOTzK-SdA0QZzPxWaQk_8cNO0OoEUl/Rebekah thesis/SUPPLEMENTATION PAPER/Data sheets/final_weight.csv")
# weight is actually mass
ivi_data <- read.csv("G:/.shortcut-targets-by-id/15aIOTzK-SdA0QZzPxWaQk_8cNO0OoEUl/Rebekah thesis/R/FINAL clean provisioning data 2013-2019.csv")

##### combine data for body mass and survival spreadsheets-----

# join the two data frames together by a common column
# 1. weight and survival spreadsheets 
combined_data <- left_join(updated_comb, updated_weight, by = c("yearsite", "site", "year", "colour"))
# check: file has same number of observations as updated_comb, good, no issues 

#2. basic info about whats included in analysis 

# number of sites in each year 
sites_count_year <- combined_data %>% 
  group_by(year) %>% 
  summarise(sites_per_year = n_distinct(site))
print(sites_count_year)
# this is maximum number included. 2 are present in IVI data but missing here (both from 2016)
# and 19 are present here but not in the IVI data 

# number of supplemented nests in each year 
control_supplemented <- combined_data %>% 
  group_by(year) %>% 
  subset(treatment == 1) %>% 
  summarise(num_supp = n_distinct(site))
print(control_supplemented)

##### create weight at final measurement (assumed fledging) spreadsheet -----

# group the data by yearsite and colour of nestling, and find the maximum age for each group
max_ages <- combined_data %>%
  group_by(yearsite, colour) %>%
  summarize(max_age = max(age))

# join the maximum ages back to the combined data to filter for only the highest age measurements
assumed_fledge_data <- combined_data %>%
  left_join(max_ages, by = c("yearsite", "colour")) %>%
  filter(age == max_age) %>%
  select(-max_age) # remove max_age column (don't need it)
# this spreadsheet then also includes only the survival data recorded at the last recorded nest visit
# but for ALL nestlings, whether they survived or not 
# later i also create a spreadsheet for use in the body mass at fledging model which only has the weights of surviving nestlings


##### calculate number hatched (ie max brood size)
assumed_fledge_data <- assumed_fledge_data %>% 
  group_by(yearsite) %>% 
  mutate(number_hatched = n_distinct(colour)) 

##### calculate number fledged 
assumed_fledge_data <- assumed_fledge_data %>% 
  group_by(yearsite) %>% 
  mutate(number_fledged = sum(surv))

##### calculate nestling age in IVI spreadsheet -----
summary(ivi_data$julian2)
ivi_data$jhatchdate <- ivi_data$julian2-186

#Create julian for date in season for relevant dataset (2013-2017)

ivi_data <- subset(ivi_data, year != 2018 & year != 2019)


summary(ivi_data$jdate2)
ivi_data$dayinseason <- ivi_data$jdate2-186 #-186 not 187 to align with hatchdate

#Calculate nestling age

ivi_data$nestlingage <- ivi_data$dayinseason - ivi_data$jhatchdate
hist(ivi_data$nestlingage) #check distribution (confirm logical)
summary(ivi_data$nestlingage) #no problems 

##### set appropriate categorical variables -----

# 1. assumed_fledge_data sheet
assumed_fledge_data$fyear = as.factor(assumed_fledge_data$year)
assumed_fledge_data$ftreatment = as.factor(assumed_fledge_data$treatment) 
assumed_fledge_data$fpair = as.factor(assumed_fledge_data$yearsite)
assumed_fledge_data$fsite = as.factor(assumed_fledge_data$site)

#2. ivi_data sheet 
ivi_data$fyear = as.factor(ivi_data$year)
ivi_data$ftreatment = as.factor(ivi_data$supplimented)
ivi_data$fpair = as.factor(ivi_data$yearsite)
ivi_data$fsite = as.factor(ivi_data$site)

##### calculate & manipulate IVI -----

# Combine provisioning start date & time

ivi_data$DTstart <- as.POSIXct(as.character(paste(ivi_data$date, ivi_data$start)), 
                           format = "%d/%m/%Y %H:%M:%S")

# Calculate IVI

ivi_data <- (data=ivi_data) %>% 
  group_by (fpair) %>% 
  arrange(DTstart) %>% 
  mutate(IVI = ifelse(visit_type == "fail"| lag(visit_type == "fail"), NA, DTstart - lag(DTstart, default = first(DTstart)))) %>% 
  ungroup()

ivi_data$IVI <- ivi_data$IVI/60

# Limit dataset to first 12 days & exclude hatch day 0

ivi_data <- (data=ivi_data) %>%
  filter(ivi_data$nestlingage <=12) 
ivi_data <- (data=ivi_data) %>%
  filter(ivi_data$nestlingage >0)


# deal with camera fail lines 
# We removed NAs since these are generated by fails recorded either on the current or previous line

ivi_data <- (data=ivi_data) %>% 
  filter(!is.na (IVI))
summary(ivi_data$IVI)

# check for outliers in IVI

dotchart(ivi_data$IVI) # outliers seem obvious, remove obvious outliers 
# Longest IVI is 9296 minutes (6.5 days) which is obviously unrealistic. It is from 2015. 
# The 7 longest IVIs are from 2015 and 2016, assumed to be related to camera settings (see manuscript)

ivi_data <- (data=ivi_data) %>%
  filter(ivi_data$IVI <4000)
dotchart(ivi_data$IVI)


# log transform IVI
hist(ivi_data$IVI)
ivi_data$logIVI <- log(ivi_data$IVI)
hist(ivi_data$logIVI)

##### centering and scaling data -----

# setting scale=2 means that the variables are scaled by 2SD instead of the automatic 1
# scaling by 2SD so that continuous perdictors in my models can be directly compared to treatment effect 
# which has 2 levels (i.e., supplemented 1 and control 0)
#Gelman A, 2008. Scaling regression inputs by dividing by two standard deviations. Stat Med 27:2865-2873.

assumed_fledge_data$hatch_date_sc <- scale(assumed_fledge_data$hatch_date_in_july, scale = 2)
assumed_fledge_data$brood_size_sc <- scale(assumed_fledge_data$number_fledged, scale = 2)
assumed_fledge_data$age_sc <- scale(assumed_fledge_data$age, scale = 2)
assumed_fledge_data$number_hatched_sc <- scale(assumed_fledge_data$number_hatched, scale = 2)

ivi_data$brood_size_sc <- scale(ivi_data$chicks, scale = 2)
ivi_data$hatch_date_sc <- scale(ivi_data$jhatchdate, scale = 2)
ivi_data$age_sc <- scale(ivi_data$nestlingage, scale = 2)

##### other manipulations needed for models -----
# determine the min and max ages at which final measurements were taken only for surviving nestlings i.e., age of assumed fledging 
# this will be used in the body mass at fledging model 
# for this we only want the fledge data i.e., the weights of the nestlings which survived until assumed fledging
# in the assumed_fledge_data spreadsheet we have all of the last weight measurements taken for each nestling colour
# so i need to filter this to only have the final weight for surviving nestlings 

filtered_assumed_fledge <- subset(assumed_fledge_data,surv ==1)
filtered_assumed_fledge <- subset(filtered_assumed_fledge, select = -age_at_death)
# range is now 21-35 days at final weight measurement for surviving nestlings 
# during this time growth is roughly linear, based on Eriks thesis figures, so dont need to remove any points as outliers 


##### Comparing datasets between fledge data and ivi data -----

# Count unique sites within years in ivi_data
ivi_unique_sites <- ivi_data %>%
  group_by(year) %>%
  summarise(unique_sites = n_distinct(site))

# Count unique sites within years in assumed_fledge_data
fledge_unique_sites <- assumed_fledge_data %>%
  group_by(year) %>%
  summarise(unique_sites = n_distinct(site))

# Print the results
print("ivi_data:")
print(ivi_unique_sites)

print("assumed_fledge_data:")
print(fledge_unique_sites)

# Get unique sites within years in ivi_data
ivi_unique_sites <- ivi_data %>%
  group_by(year) %>%
  distinct(site) %>%
  ungroup()

# Get unique sites within years in assumed_fledge_data
fledge_unique_sites <- assumed_fledge_data %>%
  group_by(year) %>%
  distinct(site) %>%
  ungroup()

# Find sites in assumed_fledge_data not present in ivi_data
sites_not_in_ivi_data <- fledge_unique_sites %>%
  anti_join(ivi_unique_sites, by = c("year", "site"))


# Find sites in ivi_data not present in assumed_fledge_data
sites_not_in_fledge_data <- ivi_unique_sites %>%
  anti_join(fledge_unique_sites, by = c("year", "site"))

# Print the results
print(sites_not_in_ivi_data)
print(sites_not_in_fledge_data)

##### models confirming no treatment related differences -----

# checking for treatment related differences prior to treatment 
# this is to confirm that the randomisation of supplemented nests was successful 

## 1. treatment related differences in hatch date 

# need only data for first hatched nestling of each pair (ie year specific site)
first_hatch_only <- assumed_fledge_data %>% 
  group_by(fpair) %>% 
  filter(hatch_date_in_july == min(hatch_date_in_july))

# use first hatched spreadsheet to check for treatment related differences 
hatch_date_test <- brm(hatch_date_in_july ~ ftreatment + (1|fsite) + (1|fyear), 
                       data = first_hatch_only, 
                       family = gaussian(), 
                       warmup = 1000, 
                       iter = 6000, 
                       chains = 3, 
                       cores = parallel::detectCores(), 
                       control = list(adapt_delta = 0.99, max_treedepth = 15), 
                       backend = "cmdstanr")
summary(hatch_date_test)
fixef(hatch_date_test)
# conc: no treatment related differences in hatch date of first nestling 

# bayesian pvalues
neg_count <- ifelse(fixef(hatch_date_test)[, 1] < 0, 1, 0) 
pos_count <- ifelse(fixef(hatch_date_test)[, 1] > 0, 1, 0)
p <- sum(neg_count) / (sum(pos_count) + sum(neg_count))
print(p)# intercept ie control

neg_count <- ifelse(fixef(hatch_date_test)[, 2] < 0, 1, 0) 
pos_count <- ifelse(fixef(hatch_date_test)[, 2] > 0, 1, 0)
p <- sum(neg_count) / (sum(pos_count) + sum(neg_count))
print(p)# supplemented 

# p-values again confirm lack of treatment related differences in hatch date 

# p-map
p_map(hatch_date_test, null=0, precision=2^10, method="kernel", effects= c("fixed"), component= c("all"))
# 0.652

## 2. treatment related differences in number of nestlings hatched 

# checking this since supplementation didnt begin until 5 days post hatch
# so shouldnt be any differences between supplemented and control assigned nests prior to treatment 
# if assignment of treatment/control was random 

number_hatched_test <- brm(number_hatched ~ ftreatment + (1|fsite) + (1|fyear), 
                           data = first_hatch_only, 
                           family = poisson(), # note poisson distribution used 
                           warmup = 3000, 
                           iter = 6000, 
                           chains = 4, 
                           cores = parallel::detectCores(), 
                           control = list(adapt_delta = 0.99, max_treedepth = 20), 
                           backend = "cmdstanr")
summary(number_hatched_test)
# conc: no treatment related differences in number of nestlings hatched 

# bayesian pvalues
neg_count <- ifelse(fixef(number_hatched_test)[, 1] < 0, 1, 0) 
pos_count <- ifelse(fixef(number_hatched_test)[, 1] > 0, 1, 0)
p <- sum(neg_count) / (sum(pos_count) + sum(neg_count))
print(p)# intercept ie control

neg_count <- ifelse(fixef(number_hatched_test)[, 2] < 0, 1, 0) 
pos_count <- ifelse(fixef(number_hatched_test)[, 2] > 0, 1, 0)
p <- sum(neg_count) / (sum(pos_count) + sum(neg_count))
print(p)# supplemented 

# p-map
p_map(number_hatched_test, null=0, precision=2^10, method="kernel", effects= c("fixed"), component= c("all"))
# 0.777

# no statistically significant difference in the number hatched between treatment groups.

## 3. treatment related differences in clutch size 

# again, clutch size formed before supplementation began so shouldn't be differences 

clutch_size_test <- brm(clutch_size ~ ftreatment + (1|fsite) + (1|fyear),
                        data = first_hatch_only, 
                        family = poisson(), # note poisson distribution used 
                        warmup = 5000, 
                        iter = 10000, 
                        chains = 4, 
                        cores = parallel::detectCores(), 
                        control = list(adapt_delta = 0.99, max_treedepth = 20), 
                        backend = "cmdstanr")
summary(clutch_size_test)

# bayesian pvalues
neg_count <- ifelse(fixef(clutch_size_test)[, 1] < 0, 1, 0) 
pos_count <- ifelse(fixef(clutch_size_test)[, 1] > 0, 1, 0)
p <- sum(neg_count) / (sum(pos_count) + sum(neg_count))
print(p)# intercept ie control

neg_count <- ifelse(fixef(clutch_size_test)[, 2] < 0, 1, 0) 
pos_count <- ifelse(fixef(clutch_size_test)[, 2] > 0, 1, 0)
p <- sum(neg_count) / (sum(pos_count) + sum(neg_count))
print(p)# supplemented 

# p-map
p_map(clutch_size_test, null=0, precision=2^10, method="kernel", effects= c("fixed"), component= c("all"))
#0.995

# no statistically significant difference in clutch size between treatment groups

##### models testing research questions -----

### 1. IVI
# we ran 2 different models for IVI. See manuscript for detailed explaination of why
# in short: if supplemented nests have higher survival = also have higher brood sizes 
# test using 2 models to tease apart effect of brood size (increased survival) versus true treatment effect

## a. IVI model including brood size as fixed effect 
ivi_model <- brm(bf(logIVI ~ 1 + ftreatment + brood_size_sc + hatch_date_sc + age_sc +
                      (1|fsite) + (1|fpair) + (1|fyear), 
                    sigma ~ 1+ ftreatment), 
                 data = ivi_data, 
                 family = gaussian(),
                 warmup = 7000, 
                 iter = 10000,
                 chains = 4, 
                 cores = parallel::detectCores(), 
                 control = list(adapt_delta = 0.99, max_treedepth = 20), 
                 backend = "cmdstanr")
summary(ivi_model)
fixef(ivi_model)
ranef(ivi_model)

# bayesian pvalues
neg_count <- ifelse(fixef(ivi_model)[, 1] < 0, 1, 0) 
pos_count <- ifelse(fixef(ivi_model)[, 1] > 0, 1, 0)
p <- sum(neg_count) / (sum(pos_count) + sum(neg_count))
print(p)# intercept ie control

neg_count <- ifelse(fixef(ivi_model)[, 2] < 0, 1, 0) 
pos_count <- ifelse(fixef(ivi_moddel)[, 2] > 0, 1, 0)
p <- sum(neg_count) / (sum(pos_count) + sum(neg_count))
print(p)# supplemented 

neg_count <- ifelse(fixef(ivi_model)[, 3] < 0, 1, 0) 
pos_count <- ifelse(fixef(ivi_model)[, 3] > 0, 1, 0)
p <- sum(neg_count) / (sum(pos_count) + sum(neg_count))
print(p)# brood size 

neg_count <- ifelse(fixef(ivi_model)[, 4] < 0, 1, 0) 
pos_count <- ifelse(fixef(ivi_moddel)[, 4] > 0, 1, 0)
p <- sum(neg_count) / (sum(pos_count) + sum(neg_count))
print(p)# hatch date 

neg_count <- ifelse(fixef(ivi_model)[, 5] < 0, 1, 0) 
pos_count <- ifelse(fixef(ivi_moddel)[, 5] > 0, 1, 0)
p <- sum(neg_count) / (sum(pos_count) + sum(neg_count))
print(p)# nestling age 

# p-map
p_map(ivi_model, null=0, precision=2^10, method="kernel", effects= c("fixed"), component= c("all"))

## b. IVI model without brood size as fixed effect 
ivi_model2 <- brm(bf(logIVI ~ 1 + ftreatment + hatch_date_sc + age_sc +
                       (1|fsite) + (1|fpair) + (1|fyear), 
                     sigma ~ 1+ ftreatment), 
                  data = ivi_data, 
                  family = gaussian(),
                  warmup = 7000, 
                  iter = 10000,
                  chains = 4, 
                  cores = parallel::detectCores(), 
                  control = list(adapt_delta = 0.99, max_treedepth = 20), 
                  backend = "cmdstanr")
summary(ivi_model2)
fixef(ivi_model2)
ranef(ivi_model2)

# bayesian pvalues
neg_count <- ifelse(fixef(ivi_model2)[, 1] < 0, 1, 0) 
pos_count <- ifelse(fixef(ivi_model2)[, 1] > 0, 1, 0)
p <- sum(neg_count) / (sum(pos_count) + sum(neg_count))
print(p)# intercept ie control

neg_count <- ifelse(fixef(ivi_model2)[, 2] < 0, 1, 0) 
pos_count <- ifelse(fixef(ivi_moddel2)[, 2] > 0, 1, 0)
p <- sum(neg_count) / (sum(pos_count) + sum(neg_count))
print(p)# supplemented 

neg_count <- ifelse(fixef(ivi_model2)[, 3] < 0, 1, 0) 
pos_count <- ifelse(fixef(ivi_model2)[, 3] > 0, 1, 0)
p <- sum(neg_count) / (sum(pos_count) + sum(neg_count))
print(p)# hatch date 

neg_count <- ifelse(fixef(ivi_model2)[, 4] < 0, 1, 0) 
pos_count <- ifelse(fixef(ivi_moddel2)[, 4] > 0, 1, 0)
p <- sum(neg_count) / (sum(pos_count) + sum(neg_count))
print(p)# nestling age 

#p-map
p_map(ivi_model2, null=0, precision=2^10, method="kernel", effects= c("all"), component= c("all"))

### 2. fledging success i.e., probability of survival to fledging 

# The "bernoulli" family assumes that the response variable follows a Bernoulli distribution, 
# which models the probability of success (survival) as a function of the predictors. 
# In the context of logistic regression, the "bernoulli" family uses a logit link function to model the log-odds (logit) of success.
# By specifying the "bernoulli" family, the model estimates the probabilities of survival based on the given predictor variables, 
# and the coefficients represent the log-odds ratios associated with the predictors.
# To summarize, the choice of the "bernoulli" family for the response variable "surv" in this case is appropriate 
# because it aligns with the binary nature of the data, allowing for the modeling of survival probabilities using logistic regression.

# note to self: change this to just being called survival_prob_model before publication 
survival_prob_model2 <- brm(bf(surv ~ ftreatment + number_hatched_sc + hatch_date_sc + 
                                 (1 | fsite) + (1 | fpair) + (1 | fyear)),
                            data = assumed_fledge_data,
                            family = bernoulli(),
                            chains = 2,
                            iter = 10000,
                            warmup = 8000,
                            cores = parallel::detectCores(),
                            control = list(adapt_delta = 0.99, max_treedepth = 10),
                            backend = "cmdstanr")

summary(survival_prob_model2)
fixef(survival_prob_model2)
ranef(survival_prob_model2)

# bayesian pvalues
neg_count <- ifelse(fixef(survival_prob_model2)[, 1] < 0, 1, 0) 
pos_count <- ifelse(fixef(survival_prob_model2)[, 1] > 0, 1, 0)
p <- sum(neg_count) / (sum(pos_count) + sum(neg_count))
print(p)# intercept ie control

neg_count <- ifelse(fixef(survival_prob_model2)[, 2] < 0, 1, 0) 
pos_count <- ifelse(fixef(survival_prob_model2)[, 2] > 0, 1, 0)
p <- sum(neg_count) / (sum(pos_count) + sum(neg_count))
print(p)# supplemented 

neg_count <- ifelse(fixef(survival_prob_model2)[, 3] < 0, 1, 0) 
pos_count <- ifelse(fixef(survival_prob_model2)[, 3] > 0, 1, 0)
p <- sum(neg_count) / (sum(pos_count) + sum(neg_count))
print(p)# number hatched 

neg_count <- ifelse(fixef(survival_prob_model2)[, 4] < 0, 1, 0) 
pos_count <- ifelse(fixef(survival_prob_model2)[, 4] > 0, 1, 0)
p <- sum(neg_count) / (sum(pos_count) + sum(neg_count))
print(p)# hatch date 

# p-map
p_map(survival_prob_model2, null=0, precision=2^10, method="kernel", effects= c("all"), component= c("all"))

# out of curiosity:
# probability that a parameter is strictly positive or negative 
p_direction(survival_prob_model2)


### 3. body mass at (assumed) fledging 

body_mass_fledge <- brm(bf(weight ~ 1 + ftreatment + brood_size_sc + hatch_date_sc + age_sc + # (called weight in spreadsheet but is actually mass values); brood size is number fledged here
                             (1|fsite) + (1|fpair) + (1|fyear), 
                        sigma ~ 1+ ftreatment), 
                        data = filtered_assumed_fledge, 
                        family = gaussian(),
                        warmup = 1000, 
                        iter = 6000,
                        chains = 4, 
                        cores = parallel::detectCores(), 
                        control = list(adapt_delta = 0.99, max_treedepth = 20), 
                        backend = "cmdstanr")

summary(body_mass_fledge)
fixef(body_mass_fledge)
ranef(body_mass_fledge)

# Bayesian p-values 
neg_count <- ifelse(fixef(body_mass_fledge)[, 1] < 0, 1, 0) 
pos_count <- ifelse(fixef(body_mass_fledge)[, 1] > 0, 1, 0)
p <- sum(neg_count) / (sum(pos_count) + sum(neg_count))
print(p)# intercept ie control

neg_count <- ifelse(fixef(body_mass_fledge)[, 2] < 0, 1, 0) 
pos_count <- ifelse(fixef(body_mass_fledge)[, 2] > 0, 1, 0)
p <- sum(neg_count) / (sum(pos_count) + sum(neg_count))
print(p)# supplemented 

neg_count <- ifelse(fixef(body_mass_fledge)[, 3] < 0, 1, 0) 
pos_count <- ifelse(fixef(body_mass_fledge)[, 3] > 0, 1, 0)
p <- sum(neg_count) / (sum(pos_count) + sum(neg_count))
print(p) # brood size

neg_count <- ifelse(fixef(body_mass_fledge)[, 4] < 0, 1, 0) 
pos_count <- ifelse(fixef(body_mass_fledge)[, 4] > 0, 1, 0)
p <- sum(neg_count) / (sum(pos_count) + sum(neg_count))
print(p) # hatch date 

neg_count <- ifelse(fixef(body_mass_fledge)[, 5] < 0, 1, 0) 
pos_count <- ifelse(fixef(body_mass_fledge)[, 5] > 0, 1, 0)
p <- sum(neg_count) / (sum(pos_count) + sum(neg_count))
print(p) # nestling age 

# p-map
p_map(body_mass_fledge, null=0, precision=2^10, method="kernel", effects= c("all"), component= c("all"))

##### creating figures -----
# Create a data frame with control data included
results <- data.frame(
  models = rep(c("IVI", "Survival", "Body Condition"), each = 2),
  estimates = c(5.00, 5.01, -0.08, 2.31, 635.89, 647.15),
  CIs_upper = c(5.24, 5.37, 1.19, 5.12, 712.52, 764.24),
  CIs_lower = c(4.77, 4.67, -1.43, -0.32, 552.75, 524.2),
  response_variable = rep(c("IVI", "Survival", "Body Condition"), each = 2),
  treatment = rep(c("Control", "Supplemented"), times = 3),
  color = factor(rep(c("Control", "Supplemented"), times = 3), levels = c("Control", "Supplemented"))
)

# Set the levels of models in the desired order
results$models <- factor(results$models, levels = c("IVI", "Survival", "Body Condition"))

# Set the levels of response_variable in the desired order
results$response_variable <- factor(results$response_variable, levels = c("IVI", "Survival", "Body Condition"))

# Assign colors and rearrange order
colors <- c("cadetblue4", "burlywood4")
names(colors) <- levels(results$color)

# Create a ggplot with three panels and grid lines
ggplot(results, aes(x = models, y = estimates, color = color)) +
  geom_point(position = position_dodge(width = 0.5), size = 4) +
  geom_errorbar(
    aes(ymin = CIs_lower, ymax = CIs_upper),
    position = position_dodge(width = 0.5),
    width = 0.2
  ) +
  scale_color_manual(values = colors) + 
  labs(y = "", x = "") +
  theme_minimal() +
  theme(legend.position = "none", 
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_rect(color = "black", size = 0.5, fill = NA),
        axis.text.x = element_blank(),  # Remove x-axis labels
        axis.text.y = element_text(size = 12, face = "bold"),  # Modify y-axis text
        axis.title.x = element_blank(),  # Remove x-axis title
        axis.title.y = element_text(size = 12, face = "bold"),
        strip.text.x = element_text(size = 12, face = "bold"),  # Modify top axis text
        strip.text.y = element_text(size = 12, face = "bold")) +  # Modify right axis text
  facet_grid(response_variable ~ treatment, scales = "free_y")

# Create a ggplot with separate panels for different traits and grid lines
final_plot <- ggplot(results, aes(x = models, y = estimates, color = color)) +
  geom_point(position = position_dodge(width = 0.5), size = 4) +
  geom_errorbar(
    aes(ymin = CIs_lower, ymax = CIs_upper),
    position = position_dodge(width = 0.5),
    width = 0.2
  ) +
  scale_color_manual(values = colors) + 
  labs(y = "", x = "") +
  theme_minimal() +
  theme(legend.position = "none", 
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_rect(color = "black", size = 0.5, fill = NA),
        axis.text.x = element_blank(),  # Remove x-axis labels
        #axis.text.x = element_text(size = 12, face = "bold"),  # Modify x-axis text
        axis.text.y = element_text(size = 12, face = "bold"),  # Modify y-axis text
        #axis.title.x = element_text(size = 12, face = "bold"),  # Modify x-axis title
        axis.title.x = element_blank(),  # Remove x-axis title
        axis.title.y = element_text(size = 12, face = "bold"),
        strip.text.x = element_text(size = 12, face = "bold"),  # Modify top axis text
        strip.text.y = element_text(size = 12, face = "bold")) +  # Modify right axis text
  facet_wrap(~ response_variable, scales = "free_y", ncol = 1)


# save fig in high res 

# Specify the file path and name
file_path <- "G:/.shortcut-targets-by-id/15aIOTzK-SdA0QZzPxWaQk_8cNO0OoEUl/Rebekah thesis/SUPPLEMENTATION PAPER/figures/Supp_Figure_1_600DPI.tiff"
  
# Save the combined plot with high DPI
ggsave(file_path, plot = final_plot, width = 12, height = 8, dpi = 600)






































##### remove before publication -----

## testing quail data stuff
quail <- read.csv("G:/.shortcut-targets-by-id/15aIOTzK-SdA0QZzPxWaQk_8cNO0OoEUl/Rebekah thesis/SUPPLEMENTATION PAPER/Data sheets/quail_pattern_test.csv")
quail$Supp <- as.numeric(quail$Supp)

#quail <- na.omit(quail)


# Convert "date" variable to date format
quail$date <- as.Date(quail$date)

# Plot the data
ggplot(quail, aes(x = date, y = Supp, color = factor(Year))) +
  geom_point() +
  geom_smooth(method = "lm", se = FALSE) +
  labs(x = "Date", y = "Supp", color = "Year") +
  theme_minimal()

library(ggplot2)

# Convert "date" variable to date format
quail$date <- as.Date(quail$date)

# Plot with separate figures for each year
ggplot(quail, aes(x = date, y = Supp)) +
  geom_point(aes(color = as.factor(Site))) +
  geom_smooth(method = "lm", se = FALSE, color = "grey") +
  labs(x = "Date", y = "Supp") +
  theme_minimal() +
  facet_wrap(~ Year, ncol = 1)



quail$date <- as.numeric(as.Date(quail$date))

cor_data <- quail %>%
  group_by(Year) %>%
  summarise(correlation = cor(Supp, date))


# Plot with separate figures for each year
ggplot(quail, aes(x = date, y = Supp)) +
  geom_point(aes(color = as.factor(Site))) +
  geom_smooth(method = "lm", se = FALSE, color = "grey") +
  labs(x = "Date", y = "Supp") +
  theme_minimal() +
  facet_wrap(~ Year, ncol = 1) +
  geom_text(data = cor_data, aes(label = paste("Correlation:", round(correlation, 2)), 
                                 x = Inf, y = Inf, hjust = 1, vjust = 1),
            color = "black", size = 4, fontface = "bold", show.legend = FALSE)



exp(0.08)


exp(5.5)/60



library(ggplot2)

# Create a data frame
results <- data.frame(
  models = c("IVI", "Survival", "Body Condition"),
  estimates = c(0.01, 2.39, 11.26),
  CIs_upper = c(0.13, 3.93, 51.72),
  CIs_lower = c(0.10, 1.11, -28.55)
)

# Create a ggplot
ggplot(results, aes(x = models, y = estimates, color = models)) +
  geom_point(position = position_dodge(width = 0.3), size = 3) +
  geom_errorbar(
    aes(ymin = CIs_lower, ymax = CIs_upper),
    position = position_dodge(width = 0.3),
    width = 0.2
  ) +
  labs(title = "Effect of Supplementation on Different Models",
       x = "Models",
       y = "Estimates") +
  theme_minimal() +
  theme(legend.position = "none")  # Remove legend if not needed

##

# Install and load necessary packages
install.packages("ggplot2")
library(ggplot2)

# Create a data frame
results <- data.frame(
  models = c("IVI", "Survival", "Body Condition"),
  estimates = c(0.01, 2.39, 11.26),
  CIs_upper = c(0.13, 3.93, 51.72),
  CIs_lower = c(-0.10, 1.11, -28.55)
)

# Assign colors and rearrange order
results$color <- factor(results$models, levels = c("IVI", "Survival", "Body Condition"))
results$models <- factor(results$models, levels = c("IVI", "Survival", "Body Condition"))
colors <- c("darkred", "darkolivegreen4", "darkred")
names(colors) <- levels(results$color)

# Create a ggplot
ggplot(results, aes(x = models, y = estimates, color = color)) +
  geom_hline(yintercept = 0, linetype = "longdash", color = "cornsilk3", size = 0.5, z = -Inf) +  # Add grey line behind points
  geom_point(position = position_dodge(width = 0), size = 4) +
  geom_errorbar(
    aes(ymin = CIs_lower, ymax = CIs_upper),
    position = position_dodge(width = 0.3),
    width = 0.2
  ) +
  scale_color_manual(values = colors) +  # Set manual color scale
  labs(y = "", x = "") +
  theme_minimal() +
  theme(legend.position = "none", 
        panel.grid.major = element_blank(),  # Remove major grid lines
        panel.grid.minor = element_blank())  # Remove minor grid lines
###

# Assign colors and rearrange order
results$color <- factor(results$models, levels = c("IVI", "Survival", "Body Condition"))
results$models <- factor(results$models, levels = c("IVI", "Survival", "Body Condition"))
colors <- c("darkred", "darkolivegreen4", "darkred")
names(colors) <- levels(results$color)

# Create a ggplot
ggplot(results, aes(x = models, y = estimates, color = color)) +
  geom_hline(yintercept = 0, linetype = "longdash", color = "grey50", size = 0.5, z = -Inf) +  # Add grey line behind points
  geom_point(position = position_dodge(width = 0), size = 4) +
  geom_errorbar(
    aes(ymin = CIs_lower, ymax = CIs_upper),
    position = position_dodge(width = 0.3),
    width = 0.2
  ) +
  scale_color_manual(values = colors) +  # Set manual color scale
  labs(y = "", x = "") +
  theme_minimal() +
  theme(legend.position = "none", 
        panel.grid.major = element_blank(),  # Remove major grid lines
        panel.grid.minor = element_blank(),  # Remove minor grid lines
        axis.text.x = element_text(size = 16, face = "bold"),  # Modify x-axis text
        axis.text.y = element_text(size = 12, face = "bold"))  # Modify y-axis text

